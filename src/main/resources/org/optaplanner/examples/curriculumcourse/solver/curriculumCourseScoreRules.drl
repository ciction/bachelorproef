/*
 * Copyright 2010 Red Hat, Inc. and/or its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.optaplanner.examples.curriculumcourse.solver;
    dialect "java"

import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScoreHolder;

import org.optaplanner.examples.curriculumcourse.domain.Course;
import org.optaplanner.examples.curriculumcourse.domain.Curriculum;
import org.optaplanner.examples.curriculumcourse.domain.CourseSchedule;
import org.optaplanner.examples.curriculumcourse.domain.Day;
import org.optaplanner.examples.curriculumcourse.domain.Lecture;
import org.optaplanner.examples.curriculumcourse.domain.Period;
import org.optaplanner.examples.curriculumcourse.domain.Room;
import org.optaplanner.examples.curriculumcourse.domain.Teacher;
import org.optaplanner.examples.curriculumcourse.domain.Timeslot;
import org.optaplanner.examples.curriculumcourse.domain.UnavailablePeriodPenalty;
import org.optaplanner.examples.curriculumcourse.domain.UnavailableDay;
import org.optaplanner.examples.curriculumcourse.domain.UnavailablePeriodAllCourses;

import org.optaplanner.examples.curriculumcourse.domain.solver.CourseConflict;


//EHB imports
import org.optaplanner.examples.curriculumcourse.domain.CourseDependency;
import  org.optaplanner.examples.curriculumcourse.domain.My_messageClass;
import java.util.ArrayList
import java.util.HashMap
import javassist.compiler.Lex

//score holder
global HardSoftScoreHolder scoreHolder;


// ############################################################################
// Hard constraints
// ############################################################################

// Lectures: A missing or extra lecture of a course.
// This hard constraint is build-in: the correct number of Lecture's is created

// Conflicts: Two conflicting lectures in the same period.
// Three conflicting lectures count as 3 violations: one for each pair.
// Hard 1
rule "conflictingLecturesDifferentCourseInSamePeriod"
    when
        $courseConflict : CourseConflict($leftCourse : leftCourse, $rightCourse : rightCourse)
        $leftLecture : Lecture(course == $leftCourse, $period : period, period != null)
        $rightLecture : Lecture(course == $rightCourse, period == $period, this != $leftLecture)
    then
        scoreHolder.addHardConstraintMatch(kcontext, - $courseConflict.getConflictCount());
end
// Hard 2
rule "conflictingLecturesSameCourseInSamePeriod"
    when
        Lecture($leftId : id, $leftCourse : course, $period : period, period != null)
        Lecture(course == $leftCourse, period == $period, id > $leftId)
    then
        scoreHolder.addHardConstraintMatch(kcontext, - (1 + $leftCourse.getCurriculumList().size()));
end

// RoomOccupancy: Two lectures in the same room at the same period.
// Any extra lecture in the same period and room counts as one more violation.
// Hard 3
rule "roomOccupancy"
    when
        Lecture($leftId : id, period != null, $period : period, room != null, $room : room)
        // $leftLecture has lowest id of the period+room combo
        not Lecture(period == $period, room == $room, id < $leftId)
        // rightLecture has the same period
        Lecture(period == $period, room == $room, id > $leftId, $rightId : id)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -1);
end

// Availabilities: Each lecture in a period unavailable for that course.
// Hard 4
rule "unavailablePeriodPenalty"
    when
        UnavailablePeriodPenalty($course : course, $period : period)
        Lecture(course == $course, period == $period)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -10);
end



// ############################################################################
// Soft constraints
// ############################################################################

// RoomCapacity: For each lecture, the number of students that attend the course should be less or equal
// than the number of seats of all the rooms that host its lectures.
// Each student above the capacity counts as 1 point of penalty.
// Soft 1
rule "roomCapacity"
    when
        $room : Room($capacity : capacity)
        Lecture(room == $room, studentSize > $capacity, $studentSize : studentSize)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, ($capacity - $studentSize));
end

// MinimumWorkingDays: The lectures of each course should be spread into a minimum number of days.
// Each day below the minimum counts as 5 points of penalty.
// Soft 2
rule "minimumWorkingDays"
    when
        $course : Course($minWorkingDaySize : minWorkingDaySize)
        $dayCount : Number(intValue < $minWorkingDaySize) from accumulate(
            $day : Day()
            and exists Lecture(course == $course, day == $day),
            count($day)
        )
        // An uninitialized schedule should have no constraints broken
        exists Lecture(course == $course, period != null)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, (($dayCount.intValue() - $minWorkingDaySize) * 5));
end

// CurriculumCompactness: Lectures belonging to a curriculum should be adjacent
// to each other (i.e., in consecutive periods).
// For a given curriculum we account for a violation every time there is one lecture not adjacent
// to any other lecture within the same day.
// Each isolated lecture in a curriculum counts as 2 points of penalty.
// Soft 3
rule "curriculumCompactness"
    when
        $curriculum : Curriculum()

        Lecture(curriculumList contains $curriculum,
            $day : day, $timeslotIndex : timeslotIndex, period != null
        )
        not Lecture(curriculumList contains $curriculum,
            day == $day, timeslotIndex == ($timeslotIndex - 1)
        )
        not Lecture(curriculumList contains $curriculum,
            day == $day, timeslotIndex == ($timeslotIndex + 1)
        )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -2);
end

// RoomStability: All lectures of a course should be given in the same room.
// Each distinct room used for the lectures of a course, but the first, counts as 1 point of penalty.
// Soft 3
rule "roomStability"
    when
        $course : Course()
        $roomCount : Number(intValue > 1) from accumulate(
            $room : Room()
            and exists Lecture(course == $course, room == $room),
            count($room)
        )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -($roomCount.intValue() - 1));
end




// ############################################################################
// EHB constraints
// ############################################################################


//geen Werkcolleges in de voormiddag
//--------------------------------------------------------------------------

// EHB 1
//geen Werkcolleges in de voormiddag
rule "Geen werkColleges in de voormiddag"
    when
        // code = naam van het vak
        $course : Course(courseType == CourseType.Werkcollege)
        //{"08:00", "09:00", "10:00", "11:00", "13:00", "14:00", "15:00", "16:00", "17:00", "18:00"};
        //eerste 4 lesuren geen abap
        Lecture(course == $course, timeslotIndex < 4 )
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -1);
end


// Voldoende PC's voorzien in lokalen
//--------------------------------------------------------------------------


// EHB 2 - PC SOFT
//aantal pc's moet voldoen (soft rule --> 1 punt per pc)
//     - er is een pc nodig voor het vak - kijk hoeveel pc's er zijn  ==> $pcCount
//     - Lectures in deze ruimte mogen met $studentSize (course) niet over $pcCount gaan
rule "Room Has Enough PCs"
     when
          $course : Course( isPCNeeded() == true )
          $room : Room($pcCount : pcCount)
          $lecture: Lecture(room == $room, course == $course, studentSize > $pcCount, $studentSize : studentSize)
      then
      //1 punt af per ontbrekende pc
      scoreHolder.addSoftConstraintMatch(kcontext, ($pcCount - $studentSize));
end



// EHB 3 - PC HARD
// Geen pc's in het lokaal terwijl ze nodig zijn (deling door nul vermijden )
rule "0 PC's available"
     when
          $course : Course( isPCNeeded() == true )
          $ZeroPcRoom : Room(pcCount <= 0)
          Lecture(room == $ZeroPcRoom, course == $course)
      then
          scoreHolder.addHardConstraintMatch(kcontext, -10);
end


// EHB 4 - PC HARD  HARD
//    aantal pc's moet voldoen   (werkt niet bij deling door 0 pc's)
//          ==> meer dan 30% tekort --> hard score punten per percent af
//          per percent boven 30 een extra hard punt af
rule "Moren Then 30 Percent PC's Missing"
     when
     //Todo remove harcoded is pc needed from course class
          $course : Course( isPCNeeded() == true )
          $room : Room($pcCount : pcCount, pcCount > 0)
          //1.3 verhouding betekent 130% studenten voor 100% pc's --> de ruimte is niet geschikt
          Lecture(room == $room, course == $course, (studentSize / $pcCount) > 1.3f, $studentSize : studentSize )
      then
        double percent = ($studentSize / ($pcCount + 0.0d));
        //- 1 hard punt per 10% schijf over 30%
        int negativeScore = (int) Math.ceil( (percent - 1.3f) * 10.0f );
          scoreHolder.addSoftConstraintMatch(kcontext, -negativeScore);
//        System.out.println("$course = " + $course);
//        System.out.println("\t studentSize = " + $studentSize);
//        System.out.println("\t $pcCount = " + $pcCount);
//        System.out.println("percent = " + percent);
//        System.out.println("\t negativeScore = " + negativeScore);
    end



// vakantiedagen of uren (over alle vakken heen)
//--------------------------------------------------------------------------


// EHB 5 - Vakantiedagen
rule "Vakantiedagen"
    when
        //overloop UnavailableDay, voor alle vrije dagen
        UnavailableDay($date : date)
        //Lectures met periods uit deze dagen mogen niet gepland worden
        $day: Day(date == $date)
        Lecture(day == $day)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -10);
end


// EHB 6 - Vakantie Uren (over alle vakken heen)
rule "Unavailable Period For All Courses"
    when
        UnavailablePeriodAllCourses($period : period)
//        Lecture(period == $period)
        Lecture(period == $period)
    then
        scoreHolder.addHardConstraintMatch(kcontext, -10);
end




rule "Maximum aantal lesuren per dag per vak respecteren (bijvoorbeeld blokken van 3u"
when
    $course: Course( )
    $dependentLecture: Lecture( course == $course, day != null)


   $sameLecture: ArrayList(size > $course.urenPerDag)
        from collect( Lecture( course == $course, day == $dependentLecture.day , day != null ));
then
//      System.out.println("3u rule");
      //-1 per vergelijking uit de arraylist ==> bvb: 5 lessen ipv maximum 3 ==> (5 * -1)
      scoreHolder.addSoftConstraintMatch(kcontext, -1 );
 end


//"CourseCompactness"
rule "CourseCompactness"
    when
        $course : Course()
        $lecture: Lecture(course == $course,
                  $day : day, $timeslotIndex : timeslotIndex, period != null)

     $sameLectures: ArrayList(size > 1)
        from collect( Lecture( course == $course, day == $day , day != null ));


        not Lecture(course == $course,
            day == $day,
            timeslotIndex == ($timeslotIndex - 1) || timeslotIndex == ($timeslotIndex + 1)
        )

    then
//        System.out.println("CourseCompactness " + $lecture.getLabel() );
//        System.out.println("$sameLectures = " + $sameLectures);
        scoreHolder.addSoftConstraintMatch(kcontext, -1);
end






//dependenicies via dependency class almost
rule "dependenicies via dependency class"
    when
     $course: Course()
     $courseDependency: CourseDependency( dependentCourse == $course.code);
     $dependentLecture: Lecture( course == $course, $dependentLecturetimeslotIndex: timeslotIndex,  period != null)

     $collectedDependencyLectures: ArrayList(size < 8)
           from collect( Lecture( course.code == $courseDependency.dependency , period < $dependentLecture.period, period != null ));
    then
        String result = "";
         for (Object obj : $collectedDependencyLectures) {
                  Lecture lecture = (Lecture)obj;
                  result += (lecture.getLabel() + " ");
              }
        System.out.println(result);
       scoreHolder.addHardConstraintMatch(kcontext, - (8  - $collectedDependencyLectures.size()) );
     end



//
////dependenicies via dependency class almost
//// memberOf !!!
//rule "dependenicies via dependency class"
//    when
//     $course: Course()
//     $courseDependencies: CourseDependency( dependentCourse == $course.code);
//     $dependentLecture: Lecture( course == $course, $dependentLecturetimeslotIndex: timeslotIndex,  period != null)
//
//      $collected: ArrayList()
//           from collect( Lecture( course.code memberOf $courseDependencies.dependencies , period < $dependentLecture.period, period != null ));
//    then
//    String result = "";
//     for (Object obj : $collected) {
//              Lecture lecture = (Lecture)obj;
//              result += (lecture.getLabel() + " ");
//          }
//    System.out.println(result);
//
//     end


//
////dependenicies via dependency class
//rule "dependenicies via dependency class"
//    when
//     $course: Course()
//     $courseDependencies: CourseDependency( dependentCourse == $course.code);
//     $dependentLecture: Lecture( course == $course, $dependentLecturetimeslotIndex: timeslotIndex,  period != null)
//
//        $depencencyCourseName: String( "sddssg")
//      $collected: ArrayList()
//           from collect( Lecture( course.code memberOf $courseDependencies.dependencies , period < $dependentLecture.period, period != null ));
//    then
//    String result = "";
//
//    List<Lecture> lectures = new ArrayList<Lecture>();
//     for (Object obj : $collected) {
//              Lecture lecture = (Lecture)obj;
//              lectures.add(lecture);
//              result += (lecture.getLabel() + " ");
//          }
//    int occurrences = Collections.frequency(animals, "bat");
//
//
//
//
//
//
//    System.out.println(result);
//    System.out.println($depencencyCourseName);
//
//     end



//
////"Dependency courses not before Dependent course"
//rule "Dependency courses not before Dependent course"
//     when
//          $dependentCourse : Course( code == "ABAP_Objects", $courseDependencies: courseDependencies )
//          $dependentLecture: Lecture( course == $dependentCourse, $dependentLecturetimeslotIndex: timeslotIndex,  period != null)
//
////          $otherCourse: Course(code in ($courseDependencies) )
//
//         $collectedDependencyLectures: ArrayList(size < 5)
////                   from collect( Lecture( course.code == "Java_EE_BIZ", period < $dependentLecture.period, period != null ));
//                   from collect( Lecture( course.code  in ($courseDependencies), period < $dependentLecture.period, period != null ));
//
//      then
//      System.out.println();
//      System.out.println("Lecture: " + $dependentLecture + " timeslotIndex: " + $dependentLecturetimeslotIndex);
//      System.out.println("$courseDependencies = " + $courseDependencies);
//      Lecture dependentLecture = (Lecture)$dependentLecture;
//      System.out.println("$dependentLecture = " + $dependentLecture.getPeriod());
//
//      System.out.println($collectedDependencyLectures);
//      for (Object obj : $collectedDependencyLectures) {
//          Lecture lecture = (Lecture)obj;
//          System.out.printf(lecture.getLabel() + " ");
//      }
////      scoreHolder.addHardConstraintMatch(kcontext, -$collectedDependencyLectures.size());
//      scoreHolder.addHardConstraintMatch(kcontext, - (5  - $collectedDependencyLectures.size()) );
//end

